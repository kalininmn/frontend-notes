Статья по организации кода на хабре: https://habr.com/ru/articles/667214/

Фактор автобуса (бас фактор) в команде:
https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80_%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D0%B0#:~:text=bus%20factor%2C%20%D0%BB%D0%B8%D0%B1%D0%BE%20truck%20factor,%D1%83%20%D0%BD%D0%B8%D1%85%20%D1%80%D0%B5%D0%B1%D1%91%D0%BD%D0%BA%D0%B0%2C%20%D0%BD%D0%B0%D1%81%D1%82%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B5%D1%81%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%BE%D0%B3%D0%BE 

Фактор показывает количество участников проекта, без которых проект не может быть завершён.
Тоже и про разработчиков.
Низкий басфактор -- плохо.
Высокий басфактор -- хорошо.
Басфактор можно поднять, если: уменьшить сложность кода; будет документация; перекрёстное обучение.


Файловая структура
1. https://ru.bem.info/methodology/filestructure/
2. https://medium.com/@vladimirmorulus/%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-react-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-609f80105e2c


Практики и паттерны проектирования:
2. GRASP
3. MVC
4. MV**


5. DDD Domain-driven design
Суть заключается в описании абстрактных моделей в той или иной предметной области.

Наборы моделей:
1. Сущности -- на идентичность сущностей указывает не набор одинаковых полей, а одинаковые данные.
В них нас интересуют только данные.
Модели могут агрегироваться (объединяться) с помощью корневой сущности.
Сущности вне агрегата могут ссылаться только на корень агрегата.
Корневая сущность согласует изменения агрегата.

Работа с моделями:
Репозиторий, как инстанс -- объект с набором методов для получения объектов предметной области с базы данных.
1. Когда часть функциональности программы не принадлежит никакому объекту -- она является сервисом.

Domain-specific modeling -- это DDD с применением domain-specific languages.
Aspect-oriented programming -- позволяет сосредоточиться на бизнес-логике, исключая техничсеские проблемы (безопасность, менеджер транзакций, логирование).

DDD совместим с model-driven engineering и model-driven architecture, где
Model-driven architecture сосредоточен на транслировании модели в код для других технологических платформ что определеляет лучшую предметную модель, 
а model-driven engineering -- методология основанная на создании и эксплуатации моделей для специфических проблем.

Command Query Responsibility Segregation (CQRS) -- архитектурный паттерн для разделения чтения данных (а 'query') от записи в данные (a 'command').
Команды мутируют состояние, иквивалентно вызову методов корня агрегатора или сущности.
Запросы читают состояние, но не мутируют его.
Агрегатный корень отвечает за выполнение логики операций и либо даёт ответ об ошибке, либо изменяет своё собственное состояние.
В свою очередь обработчик команд учитывает проблемы инфраструктуры, связанные с сохранением состояния.

Event sourcing -- архитектурный паттерн, который завязан на хранилище событий для событий сущностей.
Event sourcing + CQRS + DDD = корень агрегата отвечает за проверку и применение команд (вызванных из обработчика команд), а затем публиковать события, где:
входные данные это команда, а выходные это событие/-я (как MVC).

Всё, даже команды (a 'command') -- являются сущностями. 
В рамках Frontend эти сущности являются Class'ами.

6. Гексагональная архитектура от Алистера Кокберна + DDD.
Основа данной архитектуры - порты и адаптеры.
Порты - это интерфейсы нашего приложения,
Адаптеры -  реализация наших портов.
Гексагон - фигура, имеющая 6 сторон, шестиугольник. В нашем случае слоистая или многогранная архитектура.

Преимущества данного метода:
1. Независимость: возможность не зацикливаться на бизнес логике.
Можно задекларировать, описать схему работы нашего приложения до создания внешних сервисов, использовать замоканные данные в реализации адаптеров.
2. Гибкость: использование любых фреймворков, перенос доменов адаптеров в другие проекты, добавление новых адаптеров без изменения исходного кода.
3. Легкая изменчивость: изменения в одной области нашего приложения не влияют на другие области.

Минусы:
1. Погружение: многим разработчикам может быть сложно освоиться, особенно, при невысоком уровне знаний. Долгое время я сам отторгал данный подход, ссылаясь на его избыточность, пока не освоил систему на практике в течение нескольких месяцев.2
2. Также могут возникнуть сложности реализации с graphql.

Статья: https://habr.com/ru/articles/654629/
Обновленная структура по статье: https://github.com/jtapes/hexagonal-architecture-domain-driven-design/tree/master


7. FSD
